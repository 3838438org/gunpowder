import logging

from gunpowder.ext import tensorflow as tf
from gunpowder.nodes.generic_train import GenericTrain
from gunpowder.volume import VolumeType, Volume

logger = logging.getLogger(__name__)

class Train(GenericTrain):
    '''Tensorflow implementation of :class:`gunpowder.nodes.Train`.

    Args:

        optimizer: The toplevel tensorflow node performing a training iteration.

        loss: The tensorflow operator computing the loss.

        inputs (dict): Dictionary from :class:``VolumeType`` or batch attribute
            name as string to the names of input layers in the network.

        outputs (dict): Dictionary from :class:``VolumeType`` to the names of
            output layers in the network. New volumes will be generated by this
            node for each entry (if requested downstream).

        gradients (dict): Dictionary from :class:``VolumeType`` to the names of
            output layers in the network. New volumes containing the gradient
            of an output with respect to the loss will be generated by this
            node for each entry (if requested downstream).

        volume_specs (dict, optional): An optional dictionary of
            :class:`VolumeType` to :class:`VolumeSpec` to set the volume specs
            generated volumes (``outputs`` and ``gradients``). This is useful
            to set the ``voxel_size``, for example, if they differ from the
            voxel size of the input volumes. Only fields that are not ``None``
            in the given :class:`VolumeSpec` will be used.

        use_gpu (int): Which GPU to use. Set to ``None`` for CPU mode.
    '''

    def __init__(
            self,
            optimizer,
            loss,
            inputs,
            outputs,
            gradients,
            volume_specs=None,
            use_gpu=None):

        super(Train, self).__init__(inputs, outputs, gradients, volume_specs)
        self.optimizer = optimizer
        self.loss = loss
        self.use_gpu = use_gpu
        self.session = None

    def initialize(self):

        logger.info("Initializing tf session...")

        # TODO: use gpu
        # if self.use_gpu is not None:

        self.session = tf.Session()
        self.session.run(tf.global_variables_initializer())

    def train_step(self, batch, request):

        to_compute = {'optimizer': self.optimizer, 'loss': self.loss}
        to_compute.update(self.outputs)

        feed_dict = {}
        for network_input, input_name in self.inputs.items():
            if isinstance(network_input, VolumeType):
                feed_dict[input_name] = batch.volumes[network_input].data
            elif isinstance(network_input, str):
                feed_dict[input_name] = getattr(batch, network_input)
            else:
                raise Exception(
                    "Unknown network input type {}, can't be given to "
                    "network".format(network_input))

        outputs = self.session.run(to_compute, feed_dict=feed_dict)

        for volume_type, _ in self.outputs.items():
            if volume_type in request:
                spec = self.spec[volume_type].copy()
                spec.roi = request[volume_type].roi
                batch.volumes[volume_type] = Volume(
                    outputs[volume_type],
                    spec)

        # TODO: how to get gradients from tf?
        # if len(self.gradients) > 0:

            # diffs = self.net_io.get_output_diffs()

            # for volume_type, output_name in self.gradients.items():
                # batch.volumes[volume_type] = Volume(
                        # data=diffs[output_name][0], # strip #batch dimension
                        # roi=Roi((0,0,0),diffs[output_name][0].shape[-3:])) # dummy roi, will be corrected in process()

        batch.loss = outputs['loss']
        # TODO: get iteration
        batch.iteration = 0
